tiobe.com
1. 垃圾回收自动进行，无法精确控制，但是也会有内存泄露和 内存溢出的问题    
2. jdk development kit 包含 (jre runtime environment 包含 虚拟机 类库)+ 开发工具集合 javac...    
3. 标识符 字母，数字,\_,$;数字不能开头   
4. 命名规范，包小写，类和接口名，开头大写加驼峰，变量名，方法名开头小写加驼峰   
5. 自动类型提升 char byte short -> int与 强制类型转换   
6. 二进制，八进制，十进制，十六进制 0b,0, ,0x   
7. 进制的转换可以用Integer里的toBinaryString(int i)   
8. 编码   
9. 位运算符 << >> >>> & | ^ ~   
10. 高内聚： 类的内部数据操作细节自己完成，不允许外部干涉    
低耦合：仅对外暴露少量的方法用于使用    

### java Bean
就是一种类的设计标准，符合他的要求就可以被很好的重用  
用户可以将他打包，其他开发者可以通过jsp，servlet来使用，提供了一种随时随地的复制和黏贴功能  

1. 由java语言，写成的，可重复使用的 组件
2. 符合如下标准的java类
公共类，getter setter ，private，可序列化
https://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly


### 包
就是为了更好的管理类，见note里面够了，包和包是独立的  


### mvc设计格式
model处理数据：bean/domain，dao(DataAccessobjects),db
controller: avtivity,frament,adapter,service,base
view:utils,ui


### 关于面向对象

方法重载，方法重写  

1：一堆.jar文件组合成library（库）,
2：一堆.Class文件组打包jar包。一般情况下都是若干个.class文件能实现一组功能,这时候便可以把这些.class文件打包成.jar文件.
举例：比如说当需要使用集合类的时候,咱们需要import java.uitl.\*; 对应的就是一个jar包(.jar文件)它里面就是一堆.class文件。  


多态性的 虚拟方法和动态绑定  
就是父类引用 指向子类对象的时候，调用的是被子类覆盖重写后的方法  
这里有重载的问题，方法重载，在编译的时候就确定了函数的地址，所以他不是晚绑定，也就不是虚拟方法   -> 父类不能使用子类的方法  
特例： 不定长数组 Elemtype... name 就是数组，所以当它为参数的时候，不会造成方法的重载，而是会重写。 

三元运算符后面两个变量必须可以统一  

单元测试方法  
导入包  
通过注解的方式可以运行，注意有多种注解  

#### Object

#### static
static声明的方法不可以被重写

#### 单例模式

网站的计数器，一般也是单例模式实现，否则难以同步。  
应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。  
数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。  
项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。  
Application 也是单例的典型应用   
Windows的Task Manager (任务管理器)就是很典型的单例模式  
Windows的Recycle Bin(回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例  

main方法的参数可以自己随便起名字  
 

#### 代码块
静态代码块：用static 修饰的代码块
1. 可以有输出语句。
2. 可以对类的属性、类的声明进行初始化操作。
3. 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。
4. 若有多个静态的代码块，那么按照从上到下的顺序依次执行。
5. 静态代码块的执行要先于非静态代码块。
6. 静态代码块随着类的加载而加载，且只执行一次。

非静态代码块：没有static修饰的代码块
1. 可以有输出语句。
2. 可以对类的属性、类的声明进行初始化操作。
3. 除了调用非静态的结构外，还可以调用静态的变量或方法。
4. 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。
5. 每次创建对象的时候，都会执行一次。且先于构造器执行。

#### abstract
不能用abstract修饰变量、代码块、构造器；
不能用abstract修饰私有方法、静态方法、final的方法、final的类

#### 匿名对象，抽象类的匿名子类
method1(new Object()) // 匿名对象，没有引用指向它
abstract class Person{}
Person p = new Person{ ... ... };//抽象类的匿名子类
method1(new Person{
	... ...
})//匿名子类的匿名对象

匿名核心就是要**继承或者实现接口**，但是没有名字。只用一次    


#### 模板方法的设计模式
template method  

#### interface
jdk7: 全局常量+抽象方法  
jkd8：静态方法，默认方法
接口中定义的静态方法，只能通过接口调用  
方法的类优先原则  

compareA.super.method3() 规定，调用的方法  

#### Proxy代理模式
应用场景：

安全代理：屏蔽对真实角色的直接访问。
远程代理：通过代理类处理远程方法调用（RMI）
延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。  


分类
静态代理（静态定义代理类）
动态代理（动态生成代理类）
JDK自带的动态代理，需要反射等知识

#### 内部类
当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内
部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使
用内部类  

在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者
称为外部类。
Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完
整的名称。
Inner class的名字不能与包含它的外部类类名相同；

分类：
成员内部类（static成员内部类和非static成员内部类）
outter.new
局部内部类（不谈修饰符）、匿名内部类

